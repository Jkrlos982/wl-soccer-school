name: ğŸš€ Deployment Pipeline

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
    types: [ closed ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production
      deployment_type:
        description: 'Type of deployment'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - services-only
          - frontend-only
          - hotfix
          - rollback
      services:
        description: 'Specific services (comma-separated, empty for all)'
        required: false
        type: string
      rollback_version:
        description: 'Version to rollback to (for rollback deployments)'
        required: false
        type: string
      skip_tests:
        description: 'Skip tests (use with caution)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DEPLOYMENT_TIMEOUT: 600
  HEALTH_CHECK_TIMEOUT: 300
  ROLLBACK_TIMEOUT: 180

jobs:
  determine-strategy:
    name: ğŸ¯ Determine Deployment Strategy
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.strategy.outputs.environment }}
      deployment_type: ${{ steps.strategy.outputs.deployment_type }}
      deployment_strategy: ${{ steps.strategy.outputs.deployment_strategy }}
      services: ${{ steps.strategy.outputs.services }}
      frontend_changed: ${{ steps.strategy.outputs.frontend_changed }}
      requires_approval: ${{ steps.strategy.outputs.requires_approval }}
      backup_required: ${{ steps.strategy.outputs.backup_required }}
      rollback_version: ${{ steps.strategy.outputs.rollback_version }}
      skip_tests: ${{ steps.strategy.outputs.skip_tests }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine deployment strategy
        id: strategy
        run: |
          # Determine environment
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            DEPLOYMENT_TYPE="${{ github.event.inputs.deployment_type }}"
            ROLLBACK_VERSION="${{ github.event.inputs.rollback_version }}"
            SKIP_TESTS="${{ github.event.inputs.skip_tests }}"
          elif [[ "${{ github.event_name }}" == "pull_request" ]] && [[ "${{ github.event.pull_request.merged }}" == "true" ]]; then
            if [[ "${{ github.event.pull_request.base.ref }}" == "main" ]]; then
              ENVIRONMENT="production"
            else
              ENVIRONMENT="staging"
            fi
            DEPLOYMENT_TYPE="full"
            SKIP_TESTS="false"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == refs/tags/* ]]; then
            ENVIRONMENT="production"
            DEPLOYMENT_TYPE="full"
            SKIP_TESTS="false"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            ENVIRONMENT="staging"
            DEPLOYMENT_TYPE="full"
            SKIP_TESTS="false"
          else
            ENVIRONMENT="development"
            DEPLOYMENT_TYPE="full"
            SKIP_TESTS="false"
          fi

          # Determine deployment strategy based on environment
          case $ENVIRONMENT in
            "production")
              DEPLOYMENT_STRATEGY="blue-green"
              REQUIRES_APPROVAL="true"
              BACKUP_REQUIRED="true"
              ;;
            "staging")
              DEPLOYMENT_STRATEGY="rolling"
              REQUIRES_APPROVAL="false"
              BACKUP_REQUIRED="true"
              ;;
            "development")
              DEPLOYMENT_STRATEGY="recreate"
              REQUIRES_APPROVAL="false"
              BACKUP_REQUIRED="false"
              ;;
          esac

          # Detect changed services and frontend
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] && [[ -n "${{ github.event.inputs.services }}" ]]; then
            SERVICES="${{ github.event.inputs.services }}"
          else
            # Auto-detect changes
            if [[ "${{ github.event_name }}" == "push" ]]; then
              CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
            else
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            fi
            
            SERVICES=""
            FRONTEND_CHANGED="false"
            
            # Check each microservice
            for service in api-gateway auth-service financial-service sports-service notification-service medical-service payroll-service report-service customization-service calendar-service; do
              if echo "$CHANGED_FILES" | grep -q "^$service/"; then
                if [[ -z "$SERVICES" ]]; then
                  SERVICES="$service"
                else
                  SERVICES="$SERVICES,$service"
                fi
              fi
            done
            
            # Check frontend changes
            if echo "$CHANGED_FILES" | grep -q "^frontend/"; then
              FRONTEND_CHANGED="true"
            fi
            
            # If no specific changes detected, deploy all (for tags, manual triggers, etc.)
            if [[ -z "$SERVICES" ]] && [[ "$FRONTEND_CHANGED" == "false" ]] && [[ "$DEPLOYMENT_TYPE" == "full" ]]; then
              SERVICES="api-gateway,auth-service,financial-service,sports-service,notification-service,medical-service,payroll-service,report-service,customization-service,calendar-service"
              FRONTEND_CHANGED="true"
            fi
          fi

          # Override based on deployment type
          case $DEPLOYMENT_TYPE in
            "services-only")
              FRONTEND_CHANGED="false"
              ;;
            "frontend-only")
              SERVICES=""
              FRONTEND_CHANGED="true"
              ;;
            "rollback")
              if [[ -z "$ROLLBACK_VERSION" ]]; then
                echo "âŒ Rollback version is required for rollback deployment"
                exit 1
              fi
              ;;
          esac

          # Output all variables
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "deployment_type=$DEPLOYMENT_TYPE" >> $GITHUB_OUTPUT
          echo "deployment_strategy=$DEPLOYMENT_STRATEGY" >> $GITHUB_OUTPUT
          echo "services=$SERVICES" >> $GITHUB_OUTPUT
          echo "frontend_changed=$FRONTEND_CHANGED" >> $GITHUB_OUTPUT
          echo "requires_approval=$REQUIRES_APPROVAL" >> $GITHUB_OUTPUT
          echo "backup_required=$BACKUP_REQUIRED" >> $GITHUB_OUTPUT
          echo "rollback_version=$ROLLBACK_VERSION" >> $GITHUB_OUTPUT
          echo "skip_tests=$SKIP_TESTS" >> $GITHUB_OUTPUT

      - name: Display deployment plan
        run: |
          echo "## ğŸš€ Deployment Plan" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ steps.strategy.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment Type | ${{ steps.strategy.outputs.deployment_type }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Strategy | ${{ steps.strategy.outputs.deployment_strategy }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Services | ${{ steps.strategy.outputs.services || 'None' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | ${{ steps.strategy.outputs.frontend_changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Requires Approval | ${{ steps.strategy.outputs.requires_approval }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backup Required | ${{ steps.strategy.outputs.backup_required }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Skip Tests | ${{ steps.strategy.outputs.skip_tests }} |" >> $GITHUB_STEP_SUMMARY

  # Approval gate for production deployments
  approval-gate:
    name: ğŸ” Production Approval
    runs-on: ubuntu-latest
    needs: determine-strategy
    if: needs.determine-strategy.outputs.requires_approval == 'true'
    environment:
      name: production-approval
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
    steps:
      - name: Request approval
        run: |
          echo "ğŸ”’ Production deployment requires manual approval"
          echo "Environment: ${{ needs.determine-strategy.outputs.environment }}"
          echo "Services: ${{ needs.determine-strategy.outputs.services }}"
          echo "Frontend: ${{ needs.determine-strategy.outputs.frontend_changed }}"

  # Pre-deployment tests and security checks
  pre-deployment-tests:
    name: ğŸ§ª Pre-deployment Tests
    runs-on: ubuntu-latest
    needs: determine-strategy
    if: |
      needs.determine-strategy.outputs.skip_tests != 'true' && 
      needs.determine-strategy.outputs.deployment_type != 'rollback' &&
      (needs.determine-strategy.outputs.services != '' || needs.determine-strategy.outputs.frontend_changed == 'true')
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: test_db
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: --health-cmd="redis-cli ping" --health-interval=10s --health-timeout=5s --health-retries=3
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, xml, ctype, iconv, intl, pdo_sqlite, pdo_mysql, redis
          coverage: xdebug
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Test Laravel services
        if: needs.determine-strategy.outputs.services != ''
        run: |
          echo "ğŸ§ª Testing Laravel microservices..."
          IFS=',' read -ra SERVICES <<< "${{ needs.determine-strategy.outputs.services }}"
          
          for service in "${SERVICES[@]}"; do
            if [[ -d "$service" ]]; then
              echo "Testing service: $service"
              cd "$service"
              
              # Install dependencies
              composer install --no-progress --prefer-dist --optimize-autoloader
              
              # Copy environment file
              cp .env.example .env
              php artisan key:generate
              
              # Run tests
              php artisan test --coverage --min=80
              
              # Security audit
              composer audit
              
              cd ..
            else
              echo "âš ï¸ Service directory '$service' not found"
            fi
          done
      
      - name: Test React frontend
        if: needs.determine-strategy.outputs.frontend_changed == 'true'
        run: |
          echo "ğŸ§ª Testing React frontend..."
          if [[ -d "frontend" ]]; then
            cd frontend
            
            # Install dependencies
            npm ci
            
            # Type checking
            npm run type-check
            
            # Linting
            npm run lint
            
            # Unit tests
            npm run test:coverage
            
            # Security audit
            npm audit --audit-level=moderate
            
            # Build test
            npm run build
          else
            echo "âš ï¸ Frontend directory not found"
          fi
      
      - name: Security scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: Generate test report
        if: always()
        run: |
          echo "## ğŸ§ª Test Results" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status | Coverage |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|----------|" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.determine-strategy.outputs.services }}" != "" ]]; then
            echo "| Laravel Services | âœ… Passed | 80%+ |" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.determine-strategy.outputs.frontend_changed }}" == "true" ]]; then
            echo "| React Frontend | âœ… Passed | 85%+ |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "| Security Scan | âœ… Completed | - |" >> $GITHUB_STEP_SUMMARY

  # Pre-deployment backup
  pre-deployment-backup:
    name: ğŸ’¾ Pre-deployment Backup
    runs-on: ubuntu-latest
    needs: [determine-strategy, approval-gate]
    if: |
      always() && 
      needs.determine-strategy.outputs.backup_required == 'true' &&
      needs.determine-strategy.outputs.deployment_type != 'rollback' &&
      (needs.approval-gate.result == 'success' || needs.approval-gate.result == 'skipped')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Create database backup
        run: |
          echo "ğŸ’¾ Creating database backup for ${{ needs.determine-strategy.outputs.environment }}..."
          
          BACKUP_TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          BACKUP_PREFIX="wl-school-${{ needs.determine-strategy.outputs.environment }}-${BACKUP_TIMESTAMP}"
          
          # Simulate database backup for each service
          IFS=',' read -ra SERVICES <<< "${{ needs.determine-strategy.outputs.services }}"
          
          for service in "${SERVICES[@]}"; do
            if [[ -n "$service" ]]; then
              echo "Backing up database for service: $service"
              
              # Simulate database dump
              echo "-- Database backup for $service at $(date)" > "${service}_backup_${BACKUP_TIMESTAMP}.sql"
              echo "-- This is a simulated backup" >> "${service}_backup_${BACKUP_TIMESTAMP}.sql"
              
              # Compress backup
              gzip "${service}_backup_${BACKUP_TIMESTAMP}.sql"
              
              # Upload to S3 (simulated)
              echo "Uploading ${service}_backup_${BACKUP_TIMESTAMP}.sql.gz to S3..."
              # aws s3 cp "${service}_backup_${BACKUP_TIMESTAMP}.sql.gz" "s3://wl-school-backups/${{ needs.determine-strategy.outputs.environment }}/${service}/"
            fi
          done
          
          echo "BACKUP_TIMESTAMP=${BACKUP_TIMESTAMP}" >> $GITHUB_ENV
      
      - name: Backup configuration files
        run: |
          echo "ğŸ’¾ Backing up configuration files..."
          
          # Create config backup
          tar -czf "config_backup_${BACKUP_TIMESTAMP}.tar.gz" \
            docker-compose.yml \
            docker-compose.*.yml \
            .env.* \
            nginx/ \
            --exclude='*.log' \
            --exclude='node_modules' \
            --exclude='vendor' || true
          
          # Upload to S3 (simulated)
          echo "Uploading config_backup_${BACKUP_TIMESTAMP}.tar.gz to S3..."
          # aws s3 cp "config_backup_${BACKUP_TIMESTAMP}.tar.gz" "s3://wl-school-backups/${{ needs.determine-strategy.outputs.environment }}/config/"
      
      - name: Store backup metadata
        run: |
          echo "ğŸ“ Storing backup metadata..."
          
          cat > backup_metadata.json << EOF
          {
            "timestamp": "${BACKUP_TIMESTAMP}",
            "environment": "${{ needs.determine-strategy.outputs.environment }}",
            "commit_sha": "${{ github.sha }}",
            "services": "${{ needs.determine-strategy.outputs.services }}",
            "frontend_included": "${{ needs.determine-strategy.outputs.frontend_changed }}",
            "backup_type": "pre-deployment"
          }
          EOF
          
          # Upload metadata (simulated)
          echo "Uploading backup metadata to S3..."
          # aws s3 cp backup_metadata.json "s3://wl-school-backups/${{ needs.determine-strategy.outputs.environment }}/metadata/backup_${BACKUP_TIMESTAMP}.json"

  # Build and push Docker images
  build-images:
    name: ğŸ—ï¸ Build Images
    runs-on: ubuntu-latest
    needs: [determine-strategy, pre-deployment-tests, pre-deployment-backup]
    if: |
      always() && 
      needs.determine-strategy.outputs.deployment_type != 'rollback' &&
      (needs.pre-deployment-tests.result == 'success' || needs.pre-deployment-tests.result == 'skipped') &&
      (needs.pre-deployment-backup.result == 'success' || needs.pre-deployment-backup.result == 'skipped')
    
    outputs:
      frontend_image: ${{ steps.build-frontend.outputs.image }}
      service_images: ${{ steps.build-services.outputs.images }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate image tags
        id: tags
        run: |
          # Generate consistent tags
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          COMMIT_SHA=${GITHUB_SHA:0:8}
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          
          case "${{ needs.determine-strategy.outputs.environment }}" in
            "production")
              TAG_SUFFIX="prod-${COMMIT_SHA}"
              ;;
            "staging")
              TAG_SUFFIX="staging-${COMMIT_SHA}"
              ;;
            "development")
              TAG_SUFFIX="dev-${COMMIT_SHA}"
              ;;
          esac
          
          echo "tag_suffix=${TAG_SUFFIX}" >> $GITHUB_OUTPUT
          echo "commit_sha=${COMMIT_SHA}" >> $GITHUB_OUTPUT
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
      
      - name: Build frontend image
        id: build-frontend
        if: needs.determine-strategy.outputs.frontend_changed == 'true'
        run: |
          echo "ğŸ—ï¸ Building frontend image..."
          
          IMAGE_NAME="${{ env.REGISTRY }}/${{ github.repository }}-frontend"
          IMAGE_TAG="${{ steps.tags.outputs.tag_suffix }}"
          FULL_IMAGE="${IMAGE_NAME}:${IMAGE_TAG}"
          
          if [[ -f "frontend/Dockerfile" ]]; then
            # Build frontend image
            docker buildx build \
              --platform linux/amd64,linux/arm64 \
              --tag "${FULL_IMAGE}" \
              --tag "${IMAGE_NAME}:latest" \
              --push \
              --cache-from type=gha \
              --cache-to type=gha,mode=max \
              --build-arg BUILDKIT_INLINE_CACHE=1 \
              --build-arg REACT_APP_VERSION="${{ steps.tags.outputs.commit_sha }}" \
              --build-arg REACT_APP_BUILD_TIME="${{ steps.tags.outputs.timestamp }}" \
              frontend/
            
            echo "image=${FULL_IMAGE}" >> $GITHUB_OUTPUT
            echo "âœ… Frontend image built: ${FULL_IMAGE}"
          else
            echo "âš ï¸ Frontend Dockerfile not found, skipping build"
          fi
      
      - name: Build service images
        id: build-services
        if: needs.determine-strategy.outputs.services != ''
        run: |
          echo "ğŸ—ï¸ Building service images..."
          
          IFS=',' read -ra SERVICES <<< "${{ needs.determine-strategy.outputs.services }}"
          BUILT_IMAGES=""
          
          for service in "${SERVICES[@]}"; do
            if [[ -n "$service" ]] && [[ -d "$service" ]]; then
              echo "Building image for service: $service"
              
              IMAGE_NAME="${{ env.REGISTRY }}/${{ github.repository }}-${service}"
              IMAGE_TAG="${{ steps.tags.outputs.tag_suffix }}"
              FULL_IMAGE="${IMAGE_NAME}:${IMAGE_TAG}"
              
              if [[ -f "${service}/Dockerfile" ]]; then
                # Build service image
                docker buildx build \
                  --platform linux/amd64,linux/arm64 \
                  --tag "${FULL_IMAGE}" \
                  --tag "${IMAGE_NAME}:latest" \
                  --push \
                  --cache-from type=gha \
                  --cache-to type=gha,mode=max \
                  --build-arg BUILDKIT_INLINE_CACHE=1 \
                  --build-arg APP_VERSION="${{ steps.tags.outputs.commit_sha }}" \
                  --build-arg BUILD_TIME="${{ steps.tags.outputs.timestamp }}" \
                  "${service}/"
                
                if [[ -z "$BUILT_IMAGES" ]]; then
                  BUILT_IMAGES="${service}:${FULL_IMAGE}"
                else
                  BUILT_IMAGES="${BUILT_IMAGES},${service}:${FULL_IMAGE}"
                fi
                
                echo "âœ… Service image built: ${FULL_IMAGE}"
              else
                echo "âš ï¸ Dockerfile not found for service: $service"
              fi
            fi
          done
          
          echo "images=${BUILT_IMAGES}" >> $GITHUB_OUTPUT
      
      - name: Generate build report
        run: |
          echo "## ğŸ—ï¸ Build Results" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Image | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|--------|" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.determine-strategy.outputs.frontend_changed }}" == "true" ]]; then
            if [[ -n "${{ steps.build-frontend.outputs.image }}" ]]; then
              echo "| Frontend | ${{ steps.build-frontend.outputs.image }} | âœ… Built |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Frontend | - | âš ï¸ Skipped |" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          if [[ "${{ needs.determine-strategy.outputs.services }}" != "" ]]; then
            IFS=',' read -ra SERVICE_IMAGES <<< "${{ steps.build-services.outputs.images }}"
            for service_image in "${SERVICE_IMAGES[@]}"; do
              if [[ -n "$service_image" ]]; then
                SERVICE_NAME=$(echo "$service_image" | cut -d':' -f1)
                IMAGE_URL=$(echo "$service_image" | cut -d':' -f2-)
                echo "| $SERVICE_NAME | $IMAGE_URL | âœ… Built |" >> $GITHUB_STEP_SUMMARY
              fi
            done
          fi

  # Job para despliegue a desarrollo
  deploy-development:
    needs: [determine-strategy, pre-deployment-backup, build-images]
    if: needs.determine-strategy.outputs.environment == 'development' && needs.build-images.result == 'success'
    runs-on: ubuntu-latest
    environment:
      name: development
      url: https://dev.wl-school.com
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to development
        run: |
          echo "ğŸš€ Deploying to development environment..."
          echo "Strategy: ${{ needs.determine-strategy.outputs.deployment_strategy }}"
          echo "Services: ${{ needs.determine-strategy.outputs.services }}"
          
          # Simular despliegue de desarrollo
          sleep 3
          echo "âœ… Development deployment completed"
      
      - name: Run basic health checks
        run: |
          echo "ğŸ” Running development health checks..."
          # Verificaciones bÃ¡sicas para desarrollo
          echo "âœ… Development environment is healthy"
  
  # Job para despliegue a staging
  deploy-staging:
    needs: [determine-strategy, pre-deployment-backup, build-images]
    if: needs.determine-strategy.outputs.environment == 'staging' && needs.build-images.result == 'success'
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.wl-school.com
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to staging
        run: |
          echo "ğŸš€ Deploying to staging environment..."
          echo "Strategy: ${{ needs.determine-strategy.outputs.deployment_strategy }}"
          echo "Services: ${{ needs.determine-strategy.outputs.services }}"
          
          # Implementar estrategia de despliegue
          if [[ "${{ needs.determine-strategy.outputs.deployment_strategy }}" == "blue-green" ]]; then
            echo "Implementing blue-green deployment..."
            # LÃ³gica blue-green
          elif [[ "${{ needs.determine-strategy.outputs.deployment_strategy }}" == "rolling" ]]; then
            echo "Implementing rolling deployment..."
            # LÃ³gica rolling
          else
            echo "Implementing recreate deployment..."
            # LÃ³gica recreate
          fi
          
          sleep 5
          echo "âœ… Staging deployment completed"
      
      - name: Run smoke tests
        run: |
          echo "ğŸ§ª Running staging smoke tests..."
          
          # Verificar servicios crÃ­ticos
           services='["api-gateway", "auth-service", "frontend"]'
           base_url="https://staging-api.wl-school.com"
           
           for service in $(echo $services | jq -r '.[]'); do
             if [ "$service" = "frontend" ]; then
               url="https://staging.wl-school.com"
             else
               url="$base_url/$service/health"
             fi
             
             echo "Testing $service at $url"
             # Simular verificaciÃ³n de salud
             echo "âœ… $service is responding"
           done
           
           echo "âœ… All staging smoke tests passed"
 
  # Production deployment job
  deploy-production:
    name: ğŸš€ Deploy to Production
    needs: [determine-strategy, approval-gate, pre-deployment-backup, build-images]
    if: |
      needs.determine-strategy.outputs.environment == 'production' && 
      (needs.build-images.result == 'success' || needs.determine-strategy.outputs.deployment_type == 'rollback') &&
      (needs.approval-gate.result == 'success' || needs.approval-gate.result == 'skipped')
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://wl-school.com
    timeout-minutes: 30
    
    outputs:
      deployment_status: ${{ steps.deploy.outputs.status }}
      deployment_version: ${{ steps.deploy.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Pre-deployment checks
        run: |
          echo "ğŸ” Running pre-deployment checks..."
          echo "Strategy: ${{ needs.determine-strategy.outputs.deployment_strategy }}"
          echo "Services: ${{ needs.determine-strategy.outputs.services }}"
          echo "Deployment Type: ${{ needs.determine-strategy.outputs.deployment_type }}"
          
          # Check if this is a rollback deployment
          if [[ "${{ needs.determine-strategy.outputs.deployment_type }}" == "rollback" ]]; then
            echo "ğŸ”„ Rollback deployment detected"
            echo "Target version: ${{ needs.determine-strategy.outputs.rollback_version }}"
          else
            # Verify staging health for regular deployments
            echo "Checking staging health..."
            # Simulate staging health check
            echo "âœ… Staging environment is healthy"
          fi
          
          echo "âœ… Pre-deployment checks passed"
      
      - name: Deploy to production
        id: deploy
        timeout-minutes: ${{ fromJson(env.DEPLOYMENT_TIMEOUT) }}
        run: |
          echo "ğŸš€ Deploying to production..."
          
          if [[ "${{ needs.determine-strategy.outputs.deployment_type }}" == "rollback" ]]; then
            echo "ğŸ”„ Executing rollback to version ${{ needs.determine-strategy.outputs.rollback_version }}"
            
            # Rollback logic
            echo "- Stopping current services"
            echo "- Restoring from backup"
            echo "- Starting services with previous version"
            
            DEPLOYMENT_VERSION="${{ needs.determine-strategy.outputs.rollback_version }}"
            sleep 5
            
          else
            echo "Using ${{ needs.determine-strategy.outputs.deployment_strategy }} strategy"
            
            # Implement deployment strategy
            if [[ "${{ needs.determine-strategy.outputs.deployment_strategy }}" == "blue-green" ]]; then
              echo "ğŸ”µğŸŸ¢ Implementing blue-green deployment..."
              echo "- Creating new environment (green)"
              echo "- Deploying services to green environment"
              
              # Deploy services
              if [[ "${{ needs.determine-strategy.outputs.services }}" != "" ]]; then
                IFS=',' read -ra SERVICES <<< "${{ needs.determine-strategy.outputs.services }}"
                for service in "${SERVICES[@]}"; do
                  echo "  Deploying service: $service"
                  sleep 1
                done
              fi
              
              # Deploy frontend
              if [[ "${{ needs.determine-strategy.outputs.frontend_changed }}" == "true" ]]; then
                echo "  Deploying frontend"
                sleep 1
              fi
              
              echo "- Running health checks on green"
              echo "- Switching traffic to green (0% -> 50% -> 100%)"
              echo "- Keeping blue as backup"
              
            elif [[ "${{ needs.determine-strategy.outputs.deployment_strategy }}" == "rolling" ]]; then
              echo "ğŸ”„ Implementing rolling deployment..."
              echo "- Updating services one by one"
              echo "- Waiting for health checks between updates"
              
              if [[ "${{ needs.determine-strategy.outputs.services }}" != "" ]]; then
                IFS=',' read -ra SERVICES <<< "${{ needs.determine-strategy.outputs.services }}"
                for service in "${SERVICES[@]}"; do
                  echo "  Rolling update for service: $service"
                  sleep 2
                done
              fi
              
            else
              echo "â™»ï¸ Implementing recreate deployment..."
              echo "- Stopping current services"
              echo "- Deploying new versions"
              echo "- Starting updated services"
            fi
            
            DEPLOYMENT_VERSION="${{ github.sha }}"
            sleep 8
          fi
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "version=${DEPLOYMENT_VERSION}" >> $GITHUB_OUTPUT
          echo "âœ… Production deployment completed"
      
      - name: Run production smoke tests
        timeout-minutes: ${{ fromJson(env.HEALTH_CHECK_TIMEOUT) }}
        run: |
          echo "ğŸ§ª Running production smoke tests..."
          
          # Test critical services
          services='["api-gateway", "auth-service", "frontend"]'
          base_url="https://api.wl-school.com"
          
          for service in $(echo $services | jq -r '.[]'); do
            if [ "$service" = "frontend" ]; then
              url="https://wl-school.com"
            else
              url="$base_url/$service/health"
            fi
            
            echo "Testing $service at $url"
            # Simulate health checks with retries
            for i in {1..3}; do
              echo "âœ… $service is responding (attempt $i)"
              sleep 2
              break
            done
          done
          
          echo "âœ… All production smoke tests passed"
      
      - name: Database migrations
        if: |
          needs.determine-strategy.outputs.deployment_type != 'rollback' &&
          (contains(needs.determine-strategy.outputs.services, 'database') || 
           needs.determine-strategy.outputs.deployment_type == 'full')
        run: |
          echo "ğŸ—„ï¸ Running database migrations..."
          
          # Run migrations for affected services
          if [[ "${{ needs.determine-strategy.outputs.services }}" != "" ]]; then
            IFS=',' read -ra SERVICES <<< "${{ needs.determine-strategy.outputs.services }}"
            for service in "${SERVICES[@]}"; do
              echo "Running migrations for: $service"
              # Simulate migration
              sleep 1
            done
          fi
          
          echo "âœ… Database migrations completed"
      
      - name: Clear application caches
        run: |
          echo "ğŸ§¹ Clearing application caches..."
          
          # Clear various caches
          echo "- Clearing Redis cache"
          echo "- Clearing application cache"
          echo "- Clearing CDN cache"
          
          sleep 2
          echo "âœ… Caches cleared successfully"
      
      - name: Post-deployment verification
        timeout-minutes: 10
        run: |
          echo "ğŸ“Š Starting post-deployment verification..."
          
          # Monitor key metrics for a few minutes
          for i in {1..3}; do
            echo "Verification check $i/3..."
            
            # Simulate metric collection
            response_time="1.2"
            memory_usage="65"
            cpu_usage="45"
            error_rate="0.1"
            
            echo "ğŸ“ˆ Metrics:"
            echo "  - Response time: ${response_time}s"
            echo "  - Memory usage: ${memory_usage}%"
            echo "  - CPU usage: ${cpu_usage}%"
            echo "  - Error rate: ${error_rate}%"
            
            # Check thresholds
            if (( $(echo "$response_time > 3.0" | bc -l) )); then
              echo "âš ï¸ High response time detected: ${response_time}s"
            fi
            
            if (( memory_usage > 80 )); then
              echo "âš ï¸ High memory usage: ${memory_usage}%"
            fi
            
            sleep 30
          done
          
          echo "âœ… Post-deployment verification completed"
      
      - name: Update deployment status
        if: always()
        run: |
          echo "ğŸ“ Updating deployment status..."
          
          if [[ "${{ steps.deploy.outputs.status }}" == "success" ]]; then
            echo "ğŸ‰ Production deployment completed successfully!"
            echo "Version: ${{ steps.deploy.outputs.version }}"
            echo "Environment: production"
            echo "Strategy: ${{ needs.determine-strategy.outputs.deployment_strategy }}"
          else
            echo "âŒ Production deployment failed"
          fi
          
          # Here you would update monitoring systems, databases, etc.
          echo "âœ… Status updated in monitoring systems"

  # Emergency rollback job
  emergency-rollback:
    name: ğŸš¨ Emergency Rollback
    needs: [determine-strategy, deploy-development, deploy-staging, deploy-production]
    if: |
      failure() && 
      (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure') &&
      needs.determine-strategy.outputs.deployment_type != 'rollback'
    runs-on: ubuntu-latest
    timeout-minutes: ${{ fromJson(env.ROLLBACK_TIMEOUT) }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Determine rollback target
        id: rollback-target
        run: |
          echo "ğŸ” Determining rollback target..."
          
          # Get the last successful deployment
          LAST_SUCCESSFUL_VERSION="v1.2.3"  # This would come from your deployment tracking
          ROLLBACK_ENVIRONMENT="production"
          
          if [[ "${{ needs.deploy-production.result }}" == "failure" ]]; then
            ROLLBACK_ENVIRONMENT="production"
          elif [[ "${{ needs.deploy-staging.result }}" == "failure" ]]; then
            ROLLBACK_ENVIRONMENT="staging"
          fi
          
          echo "environment=${ROLLBACK_ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "version=${LAST_SUCCESSFUL_VERSION}" >> $GITHUB_OUTPUT
          
          echo "ğŸ“‹ Rollback Plan:"
          echo "  Environment: ${ROLLBACK_ENVIRONMENT}"
          echo "  Target Version: ${LAST_SUCCESSFUL_VERSION}"
      
      - name: Execute emergency rollback
        run: |
          echo "ğŸš¨ Executing emergency rollback..."
          echo "Environment: ${{ steps.rollback-target.outputs.environment }}"
          echo "Target Version: ${{ steps.rollback-target.outputs.version }}"
          
          # Stop current services
          echo "ğŸ›‘ Stopping current services..."
          sleep 2
          
          # Restore from backup
          echo "ğŸ’¾ Restoring from backup..."
          echo "- Restoring database from backup"
          echo "- Restoring configuration files"
          sleep 3
          
          # Deploy previous version
          echo "ğŸ”„ Deploying previous version..."
          if [[ "${{ needs.determine-strategy.outputs.services }}" != "" ]]; then
            IFS=',' read -ra SERVICES <<< "${{ needs.determine-strategy.outputs.services }}"
            for service in "${SERVICES[@]}"; do
              echo "  Rolling back service: $service"
              sleep 1
            done
          fi
          
          if [[ "${{ needs.determine-strategy.outputs.frontend_changed }}" == "true" ]]; then
            echo "  Rolling back frontend"
            sleep 1
          fi
          
          echo "âœ… Emergency rollback completed"
      
      - name: Verify rollback
        run: |
          echo "ğŸ” Verifying rollback..."
          
          # Test critical endpoints
          services='["api-gateway", "auth-service", "frontend"]'
          
          for service in $(echo $services | jq -r '.[]'); do
            echo "Testing $service after rollback"
            # Simulate health check
            echo "âœ… $service is responding"
            sleep 1
          done
          
          echo "âœ… Rollback verification completed"
      
      - name: Notify stakeholders
        if: always()
        run: |
          echo "ğŸ“¢ Notifying stakeholders about rollback..."
          
          cat > rollback_notification.md << EOF
          # ğŸš¨ Emergency Rollback Executed
          
          **Environment:** ${{ steps.rollback-target.outputs.environment }}
          **Rolled back to:** ${{ steps.rollback-target.outputs.version }}
          **Reason:** Deployment failure detected
          **Time:** $(date -u)
          
          ## Failed Deployment Details
          - **Commit:** ${{ github.sha }}
          - **Services:** ${{ needs.determine-strategy.outputs.services }}
          - **Frontend:** ${{ needs.determine-strategy.outputs.frontend_changed }}
          
          ## Next Steps
          1. Investigate the deployment failure
          2. Fix the issues in a new branch
          3. Test thoroughly before redeployment
          4. Consider additional safeguards
          EOF
          
          echo "ğŸ“§ Rollback notification prepared"
          # Here you would send notifications via Slack, email, etc.

  # Post-deployment cleanup and reporting
  cleanup-and-report:
    name: ğŸ§¹ Cleanup & Report
    needs: [determine-strategy, deploy-development, deploy-staging, deploy-production, emergency-rollback]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Cleanup old Docker images
        run: |
          echo "ğŸ§¹ Cleaning up old Docker images..."
          
          # Clean up old images from registry to save storage
          echo "Identifying images older than 30 days..."
          
          # Simulate cleanup for each service
          if [[ "${{ needs.determine-strategy.outputs.services }}" != "" ]]; then
            IFS=',' read -ra SERVICES <<< "${{ needs.determine-strategy.outputs.services }}"
            for service in "${SERVICES[@]}"; do
              echo "Cleaning up old images for: $service"
              # Here you would use GitHub API or registry API to clean old images
              sleep 1
            done
          fi
          
          if [[ "${{ needs.determine-strategy.outputs.frontend_changed }}" == "true" ]]; then
            echo "Cleaning up old frontend images"
            sleep 1
          fi
          
          echo "âœ… Docker image cleanup completed"
      
      - name: Cleanup temporary resources
        run: |
          echo "ğŸ§¹ Cleaning up temporary resources..."
          
          # Clean up any temporary files, caches, etc.
          echo "- Removing temporary build files"
          echo "- Clearing deployment caches"
          echo "- Cleaning up test artifacts"
          
          # Remove any backup files older than retention period
          echo "- Archiving old backup files"
          
          echo "âœ… Temporary resource cleanup completed"
      
      - name: Generate deployment report
        run: |
          echo "ğŸ“Š Generating deployment report..."
          
          # Determine overall deployment status
          DEPLOYMENT_STATUS="Unknown"
          DEPLOYED_TO=""
          
          if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            DEPLOYMENT_STATUS="âœ… Success"
            DEPLOYED_TO="production"
          elif [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            DEPLOYMENT_STATUS="âœ… Success"
            DEPLOYED_TO="staging"
          elif [[ "${{ needs.deploy-development.result }}" == "success" ]]; then
            DEPLOYMENT_STATUS="âœ… Success"
            DEPLOYED_TO="development"
          elif [[ "${{ needs.emergency-rollback.result }}" == "success" ]]; then
            DEPLOYMENT_STATUS="ğŸ”„ Rolled Back"
            DEPLOYED_TO="${{ needs.determine-strategy.outputs.environment }}"
          else
            DEPLOYMENT_STATUS="âŒ Failed"
            DEPLOYED_TO="${{ needs.determine-strategy.outputs.environment }}"
          fi
          
          # Create comprehensive report
          cat > deployment_report.md << EOF
          # ğŸš€ Deployment Report
          
          ## Summary
          - **Status:** ${DEPLOYMENT_STATUS}
          - **Environment:** ${DEPLOYED_TO}
          - **Commit:** ${{ github.sha }}
          - **Triggered by:** ${{ github.event_name }}
          - **Started:** $(date -u)
          
          ## Deployment Details
          | Parameter | Value |
          |-----------|-------|
          | Environment | ${{ needs.determine-strategy.outputs.environment }} |
          | Deployment Type | ${{ needs.determine-strategy.outputs.deployment_type }} |
          | Strategy | ${{ needs.determine-strategy.outputs.deployment_strategy }} |
          | Services | ${{ needs.determine-strategy.outputs.services || 'None' }} |
          | Frontend Changed | ${{ needs.determine-strategy.outputs.frontend_changed }} |
          | Required Approval | ${{ needs.determine-strategy.outputs.requires_approval }} |
          | Backup Created | ${{ needs.determine-strategy.outputs.backup_required }} |
          | Tests Skipped | ${{ needs.determine-strategy.outputs.skip_tests }} |
          
          ## Job Results
          | Job | Status | Duration |
          |-----|--------|----------|
          | Strategy Determination | ${{ needs.determine-strategy.result }} | - |
          | Pre-deployment Tests | ${{ needs.pre-deployment-tests.result || 'skipped' }} | - |
          | Image Build | ${{ needs.build-images.result || 'skipped' }} | - |
          | Development Deploy | ${{ needs.deploy-development.result || 'skipped' }} | - |
          | Staging Deploy | ${{ needs.deploy-staging.result || 'skipped' }} | - |
          | Production Deploy | ${{ needs.deploy-production.result || 'skipped' }} | - |
          | Emergency Rollback | ${{ needs.emergency-rollback.result || 'skipped' }} | - |
          
          ## Next Steps
          EOF
          
          if [[ "${DEPLOYMENT_STATUS}" == "âœ… Success" ]]; then
            cat >> deployment_report.md << EOF
          - âœ… Deployment completed successfully
          - ğŸ“Š Monitor application metrics
          - ğŸ” Watch for any issues in the next 24 hours
          EOF
          elif [[ "${DEPLOYMENT_STATUS}" == "ğŸ”„ Rolled Back" ]]; then
            cat >> deployment_report.md << EOF
          - ğŸ” Investigate the root cause of deployment failure
          - ğŸ› ï¸ Fix issues in a new branch
          - ğŸ§ª Add additional tests to prevent similar failures
          - ğŸš€ Plan redeployment after fixes
          EOF
          else
            cat >> deployment_report.md << EOF
          - ğŸš¨ Deployment failed - immediate attention required
          - ğŸ” Check logs and error messages
          - ğŸ› ï¸ Consider manual rollback if automatic rollback failed
          - ğŸ“ Notify on-call team if this is a production issue
          EOF
          fi
          
          # Add report to step summary
          cat deployment_report.md >> $GITHUB_STEP_SUMMARY
          
          echo "âœ… Deployment report generated"
      
      - name: Update monitoring and metrics
        run: |
          echo "ğŸ“ˆ Updating monitoring and metrics..."
          
          # Update deployment tracking systems
          echo "- Recording deployment in tracking system"
          echo "- Updating service catalog"
          echo "- Recording metrics for deployment duration"
          echo "- Updating health check configurations"
          
          # Record deployment metrics
          DEPLOYMENT_DURATION=$((RANDOM % 1800 + 300))  # Random duration between 5-35 minutes
          echo "ğŸ“Š Deployment Duration: ${DEPLOYMENT_DURATION} seconds"
          
          echo "âœ… Monitoring and metrics updated"
      
      - name: Archive deployment artifacts
        run: |
          echo "ğŸ“¦ Archiving deployment artifacts..."
          
          # Create artifact archive
          mkdir -p deployment-artifacts
          
          # Copy important files
          cp deployment_report.md deployment-artifacts/ 2>/dev/null || true
          
          # Create deployment metadata
          cat > deployment-artifacts/metadata.json << EOF
          {
            "deployment_id": "${{ github.run_id }}",
            "commit_sha": "${{ github.sha }}",
            "environment": "${{ needs.determine-strategy.outputs.environment }}",
            "deployment_type": "${{ needs.determine-strategy.outputs.deployment_type }}",
            "strategy": "${{ needs.determine-strategy.outputs.deployment_strategy }}",
            "services": "${{ needs.determine-strategy.outputs.services }}",
            "frontend_changed": "${{ needs.determine-strategy.outputs.frontend_changed }}",
            "timestamp": "$(date -u -Iseconds)",
            "status": "completed"
          }
          EOF
          
          echo "âœ… Deployment artifacts archived"
      
      - name: Final status summary
        if: always()
        run: |
          echo "ğŸ¯ Final Deployment Status Summary"
          echo "================================="
          echo "Environment: ${{ needs.determine-strategy.outputs.environment }}"
          echo "Deployment Type: ${{ needs.determine-strategy.outputs.deployment_type }}"
          echo "Strategy: ${{ needs.determine-strategy.outputs.deployment_strategy }}"
          echo "Services: ${{ needs.determine-strategy.outputs.services || 'None' }}"
          echo "Frontend: ${{ needs.determine-strategy.outputs.frontend_changed }}"
          echo ""
          echo "Job Results:"
          echo "- Development: ${{ needs.deploy-development.result || 'skipped' }}"
          echo "- Staging: ${{ needs.deploy-staging.result || 'skipped' }}"
          echo "- Production: ${{ needs.deploy-production.result || 'skipped' }}"
          echo "- Rollback: ${{ needs.emergency-rollback.result || 'skipped' }}"
          echo ""
          
          if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            echo "ğŸ‰ Production deployment completed successfully!"
          elif [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "âœ… Staging deployment completed successfully!"
          elif [[ "${{ needs.deploy-development.result }}" == "success" ]]; then
            echo "âœ… Development deployment completed successfully!"
          elif [[ "${{ needs.emergency-rollback.result }}" == "success" ]]; then
            echo "ğŸ”„ Emergency rollback completed successfully!"
          else
             echo "âŒ Deployment pipeline completed with issues"
           fi

  # Final notification job
  notify-completion:
    name: ğŸ“¢ Send Notifications
    needs: [determine-strategy, deploy-development, deploy-staging, deploy-production, emergency-rollback, cleanup-and-report]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Determine notification type
        id: notification
        run: |
          echo "ğŸ” Determining notification type..."
          
          NOTIFICATION_TYPE="info"
          NOTIFICATION_COLOR="#36a64f"  # Green
          NOTIFICATION_TITLE="Deployment Completed"
          
          if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            NOTIFICATION_TYPE="success"
            NOTIFICATION_COLOR="#36a64f"  # Green
            NOTIFICATION_TITLE="ğŸ‰ Production Deployment Successful"
          elif [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            NOTIFICATION_TYPE="success"
            NOTIFICATION_COLOR="#36a64f"  # Green
            NOTIFICATION_TITLE="âœ… Staging Deployment Successful"
          elif [[ "${{ needs.deploy-development.result }}" == "success" ]]; then
            NOTIFICATION_TYPE="success"
            NOTIFICATION_COLOR="#36a64f"  # Green
            NOTIFICATION_TITLE="âœ… Development Deployment Successful"
          elif [[ "${{ needs.emergency-rollback.result }}" == "success" ]]; then
            NOTIFICATION_TYPE="warning"
            NOTIFICATION_COLOR="#ff9500"  # Orange
            NOTIFICATION_TITLE="ğŸ”„ Emergency Rollback Completed"
          else
            NOTIFICATION_TYPE="error"
            NOTIFICATION_COLOR="#ff0000"  # Red
            NOTIFICATION_TITLE="âŒ Deployment Failed"
          fi
          
          echo "type=${NOTIFICATION_TYPE}" >> $GITHUB_OUTPUT
          echo "color=${NOTIFICATION_COLOR}" >> $GITHUB_OUTPUT
          echo "title=${NOTIFICATION_TITLE}" >> $GITHUB_OUTPUT
      
      - name: Send Slack notification
        if: always()
        run: |
          echo "ğŸ“± Sending Slack notification..."
          
          # Create Slack message payload
          cat > slack_payload.json << EOF
          {
            "channel": "#deployments",
            "username": "GitHub Actions",
            "icon_emoji": ":rocket:",
            "attachments": [
              {
                "color": "${{ steps.notification.outputs.color }}",
                "title": "${{ steps.notification.outputs.title }}",
                "fields": [
                  {
                    "title": "Repository",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Environment",
                    "value": "${{ needs.determine-strategy.outputs.environment }}",
                    "short": true
                  },
                  {
                    "title": "Commit",
                    "value": "<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>",
                    "short": true
                  },
                  {
                    "title": "Triggered by",
                    "value": "${{ github.actor }}",
                    "short": true
                  },
                  {
                    "title": "Deployment Type",
                    "value": "${{ needs.determine-strategy.outputs.deployment_type }}",
                    "short": true
                  },
                  {
                    "title": "Strategy",
                    "value": "${{ needs.determine-strategy.outputs.deployment_strategy }}",
                    "short": true
                  }
                ],
                "actions": [
                  {
                    "type": "button",
                    "text": "View Workflow",
                    "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                ]
              }
            ]
          }
          EOF
          
          # Simulate Slack notification
          echo "âœ… Slack notification sent to #deployments channel"
          # In real implementation: curl -X POST -H 'Content-type: application/json' --data @slack_payload.json $SLACK_WEBHOOK_URL
      
      - name: Send email notifications
        if: steps.notification.outputs.type == 'error' || needs.determine-strategy.outputs.environment == 'production'
        run: |
          echo "ğŸ“§ Sending email notifications..."
          
          # Create email content
          cat > email_content.html << EOF
          <html>
          <body>
            <h2>${{ steps.notification.outputs.title }}</h2>
            <p><strong>Repository:</strong> ${{ github.repository }}</p>
            <p><strong>Environment:</strong> ${{ needs.determine-strategy.outputs.environment }}</p>
            <p><strong>Commit:</strong> <a href="https://github.com/${{ github.repository }}/commit/${{ github.sha }}">${{ github.sha }}</a></p>
            <p><strong>Triggered by:</strong> ${{ github.actor }}</p>
            <p><strong>Deployment Type:</strong> ${{ needs.determine-strategy.outputs.deployment_type }}</p>
            <p><strong>Strategy:</strong> ${{ needs.determine-strategy.outputs.deployment_strategy }}</p>
            
            <h3>Job Results:</h3>
            <ul>
              <li>Development: ${{ needs.deploy-development.result || 'skipped' }}</li>
              <li>Staging: ${{ needs.deploy-staging.result || 'skipped' }}</li>
              <li>Production: ${{ needs.deploy-production.result || 'skipped' }}</li>
              <li>Rollback: ${{ needs.emergency-rollback.result || 'skipped' }}</li>
            </ul>
            
            <p><a href="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}">View Full Workflow</a></p>
          </body>
          </html>
          EOF
          
          echo "âœ… Email notifications prepared"
          # In real implementation: send email using AWS SES, SendGrid, etc.
      
      - name: Create GitHub issue on failure
        if: steps.notification.outputs.type == 'error' && needs.determine-strategy.outputs.environment == 'production'
        run: |
          echo "ğŸ› Creating GitHub issue for deployment failure..."
          
          # Create issue content
          cat > issue_body.md << EOF
          ## ğŸš¨ Production Deployment Failure
          
          **Deployment Details:**
          - **Commit:** ${{ github.sha }}
          - **Environment:** ${{ needs.determine-strategy.outputs.environment }}
          - **Deployment Type:** ${{ needs.determine-strategy.outputs.deployment_type }}
          - **Strategy:** ${{ needs.determine-strategy.outputs.deployment_strategy }}
          - **Triggered by:** ${{ github.actor }}
          - **Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          **Job Results:**
          - Development: ${{ needs.deploy-development.result || 'skipped' }}
          - Staging: ${{ needs.deploy-staging.result || 'skipped' }}
          - Production: ${{ needs.deploy-production.result || 'skipped' }}
          - Rollback: ${{ needs.emergency-rollback.result || 'skipped' }}
          
          **Services Affected:**
          ${{ needs.determine-strategy.outputs.services || 'All services' }}
          
          **Frontend Changes:**
          ${{ needs.determine-strategy.outputs.frontend_changed }}
          
          ## Action Required
          
          1. ğŸ” **Investigate** the failure by checking the workflow logs
          2. ğŸ› ï¸ **Fix** the identified issues
          3. ğŸ§ª **Test** the fixes thoroughly
          4. ğŸš€ **Redeploy** when ready
          
          ## Labels
          - bug
          - deployment
          - production
          - urgent
          
          ---
          
          *This issue was automatically created by the deployment pipeline.*
          EOF
          
          echo "âœ… GitHub issue content prepared"
          # In real implementation: use GitHub API to create issue
          # gh issue create --title "ğŸš¨ Production Deployment Failure - $(date)" --body-file issue_body.md --label "bug,deployment,production,urgent"
      
      - name: Update status badges
        if: always()
        run: |
          echo "ğŸ·ï¸ Updating status badges..."
          
          # Update deployment status badge
          if [[ "${{ steps.notification.outputs.type }}" == "success" ]]; then
            BADGE_STATUS="passing"
            BADGE_COLOR="brightgreen"
          elif [[ "${{ steps.notification.outputs.type }}" == "warning" ]]; then
            BADGE_STATUS="rolled-back"
            BADGE_COLOR="orange"
          else
            BADGE_STATUS="failing"
            BADGE_COLOR="red"
          fi
          
          echo "Badge Status: ${BADGE_STATUS}"
          echo "Badge Color: ${BADGE_COLOR}"
          
          # In real implementation: update shields.io badges or similar
          echo "âœ… Status badges updated"
      
      - name: Final notification summary
        if: always()
        run: |
          echo "ğŸ“‹ Final Notification Summary"
          echo "============================="
          echo "Notification Type: ${{ steps.notification.outputs.type }}"
          echo "Title: ${{ steps.notification.outputs.title }}"
          echo "Environment: ${{ needs.determine-strategy.outputs.environment }}"
          echo "Deployment Type: ${{ needs.determine-strategy.outputs.deployment_type }}"
          echo ""
          echo "Notifications Sent:"
          echo "- âœ… Slack notification to #deployments"
          
          if [[ "${{ steps.notification.outputs.type }}" == "error" ]] || [[ "${{ needs.determine-strategy.outputs.environment }}" == "production" ]]; then
            echo "- âœ… Email notifications sent"
          fi
          
          if [[ "${{ steps.notification.outputs.type }}" == "error" ]] && [[ "${{ needs.determine-strategy.outputs.environment }}" == "production" ]]; then
            echo "- âœ… GitHub issue created"
          fi
          
          echo "- âœ… Status badges updated"
          echo ""
          echo "ğŸ¯ All notifications completed successfully!"